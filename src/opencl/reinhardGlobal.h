const char *reinhardGlobal_kernel =
"// reinhardGlobal.cl (HDR)\n"
"// Copyright (c) 2014, Amir Chohan,\n"
"// University of Bristol. All rights reserved.\n"
"//\n"
"// This program is provided under a three-clause BSD license. For full\n"
"// license terms please see the LICENSE file distributed with this\n"
"// source code.\n"
"\n"
"float3 GLtoCL(uint3 val);\n"
"float3 RGBtoXYZ(float3 rgb);\n"
"\n"
"const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_NONE | CLK_FILTER_NEAREST;\n"
"\n"
"//this kernel computes logAvgLum and Lwhite by performing reduction\n"
"//the results are stored in an array of size num_work_groups\n"
"kernel void computeLogAvgLum( 	__read_only image2d_t image,\n"
"								__global float* logAvgLum,\n"
"								__global float* Lwhite,\n"
"								__local float* Lwhite_loc,\n"
"								__local float* logAvgLum_loc) {\n"
"\n"
"	float lum;\n"
"	float Lwhite_acc = 0.f;		//maximum luminance in the image\n"
"	float logAvgLum_acc = 0.f;\n"
"\n"
"	int2 pos;\n"
"	uint4 pixel;\n"
"	for (pos.y = get_global_id(1); pos.y < HEIGHT; pos.y += get_global_size(1)) {\n"
"		for (pos.x = get_global_id(0); pos.x < WIDTH; pos.x += get_global_size(0)) {\n"
"			pixel = read_imageui(image, sampler, pos);\n"
"			// lum = pixel.x * 0.2126f + pixel.y * 0.7152f + pixel.z * 0.0722f;\n"
"			lum = dot(GLtoCL(pixel.xyz), (float3)(0.2126f, 0.7152f, 0.0722f));\n"
"\n"
"			Lwhite_acc = max(lum, Lwhite_acc);\n"
"			logAvgLum_acc += log(lum + 0.000001f);\n"
"		}\n"
"	}\n"
"\n"
"	size_t lid = get_local_id(0) + get_local_id(1)*get_local_size(0);	//linearised local id\n"
"	Lwhite_loc[lid] = Lwhite_acc;\n"
"	logAvgLum_loc[lid] = logAvgLum_acc;\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"	// Perform parallel reduction\n"
"	for(int offset = (get_local_size(0)*get_local_size(1))/2; offset > 0; offset = offset/2) {\n"
"		if (lid < offset) {\n"
"			Lwhite_loc[lid] = max(Lwhite_loc[lid+offset], Lwhite_loc[lid]);\n"
"			logAvgLum_loc[lid] += logAvgLum_loc[lid + offset];\n"
"		}\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"	}\n"
"\n"
"	if (lid == 0) {\n"
"		size_t group_id = get_group_id(0) + get_group_id(1)*get_num_groups(0);\n"
"		Lwhite[group_id] = Lwhite_loc[0];\n"
"		logAvgLum[group_id] = logAvgLum_loc[0];\n"
"	}\n"
"}\n"
"\n"
"//combines the results of computeLogAvgLum kernel\n"
"kernel void finalReduc(	__global float* logAvgLum_acc,\n"
"						__global float* Lwhite_acc,\n"
"						const uint num_reduc_bins) {\n"
"	if (get_global_id(0) == 0) {\n"
"\n"
"		float Lwhite = 0.f;\n"
"		float logAvgLum = 0.f;\n"
"	\n"
"		for (uint i = 0; i < num_reduc_bins; i++) {\n"
"			Lwhite = max(Lwhite, Lwhite_acc[i]);\n"
"			logAvgLum += logAvgLum_acc[i];\n"
"		}\n"
"		Lwhite_acc[0] = Lwhite;\n"
"		logAvgLum_acc[0] = exp(logAvgLum/(convert_float(WIDTH*HEIGHT)));\n"
"	}\n"
"	else return;\n"
"}\n"
"\n"
"//Reinhard's Global Tone-Mapping Operator\n"
"kernel void reinhardGlobal(	__read_only image2d_t input_image,\n"
"							__write_only image2d_t output_image,\n"
"							__global float* logAvgLum_acc,\n"
"							__global float* Lwhite_acc) {\n"
"	float Lwhite = Lwhite_acc[0];\n"
"	float logAvgLum = logAvgLum_acc[0];\n"
"\n"
"	int2 pos;\n"
"	uint4 pixel;\n"
"	float3 rgb, xyz;\n"
"	for (pos.y = get_global_id(1); pos.y < HEIGHT; pos.y += get_global_size(1)) {\n"
"		for (pos.x = get_global_id(0); pos.x < WIDTH; pos.x += get_global_size(0)) {\n"
"			pixel = read_imageui(input_image, sampler, pos);\n"
"\n"
"			rgb = GLtoCL(pixel.xyz);\n"
"			xyz = RGBtoXYZ(rgb);\n"
"\n"
"			float L\t= ((KEY*1.f)/logAvgLum) * xyz.y;\n"
"			float Ld = (L * (1.f + L/(Lwhite * Lwhite))) / (1.f + L);\n"
"\n"
"			pixel.xyz = convert_uint3((float3)255.f * \\\n"
"				clamp((pow(rgb.xyz/xyz.y, (float3)SAT)*(float3)Ld), 0.f, 1.f));\n"
"\n"
"			write_imageui(output_image, pos, pixel);\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"\n"
"//convert an RGB pixel to XYZ format:\n"
"//	xyz.x = rgb.x*0.4124f + rgb.y*0.3576f + rgb.z*0.1805f;\n"
"//	xyz.y = rgb.x*0.2126f + rgb.y*0.7152f + rgb.z*0.0722f;\n"
"//	xyz.z = rgb.x*0.0193f + rgb.y*0.1192f + rgb.z*0.9505f;\n"
"float3 RGBtoXYZ(float3 rgb) {\n"
"	float3 xyz;\n"
"	xyz.x = dot(rgb, (float3)(0.4124f, 0.3576f, 0.1805f)); // will be optimised away\n"
"	xyz.y = dot(rgb, (float3)(0.2126f, 0.7152f, 0.0722f));\n"
"	xyz.z = dot(rgb, (float3)(0.0193f, 0.1192f, 0.9505f)); // will be optimised away\n"
"	return xyz;\n"
"}\n"
"\n"
"\n"
"//convert a single OpenGL texture pixel component to an OpenCL texture pixel component\n"
"float GLtoCL1(uint val) {\n"
"	float valf = convert_float(val);\n"
"#if 1 == BUGGY_CL_GL\n"
"	// a workaround for Snapdragon's Android OpenCL implementation\n"
"	if (val >= 14340) return round(0.1245790f*valf - 1658.44f);	//>=128\n"
"	if (val >= 13316) return round(0.0622869f*valf - 765.408f);	//>=64\n"
"	if (val >= 12292) return round(0.0311424f*valf - 350.800f);	//>=32\n"
"	if (val >= 11268) return round(0.0155702f*valf - 159.443f);	//>=16\n"
"	\n"
"	return round(\n"
"		pow(valf, 4.f) * 0.0000000000000125922f -\n"
"		pow(valf, 3.f) * 0.00000000026729f +\n"
"		pow(valf, 2.f) * 0.00000198135f -\n"
"		valf * 0.00496681f -\n"
"		0.0000808829f);\n"
"#else\n"
"	return valf;\n"
"#endif\n"
"}\n"
"\n"
"\n"
"//convert an OpenGL texture pixel to an OpenCL texture pixel\n"
"float3 GLtoCL(uint3 val) {\n"
"	return (float3)(GLtoCL1(val.x), GLtoCL1(val.y), GLtoCL1(val.z));\n"
"}\n"
;
