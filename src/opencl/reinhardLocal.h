const char *reinhardLocal_kernel =
"// reinhardLocal.cl (HDR)\n"
"// Copyright (c) 2014, Amir Chohan,\n"
"// University of Bristol. All rights reserved.\n"
"//\n"
"// This program is provided under a three-clause BSD license. For full\n"
"// license terms please see the LICENSE file distributed with this\n"
"// source code.\n"
"\n"
"\n"
"float3 GLtoCL(uint3 val);\n"
"float3 RGBtoXYZ(float3 rgb);\n"
"\n"
"const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_NONE | CLK_FILTER_NEAREST;\n"
"\n"
"//this kernel computes logAvgLum by performing reduction\n"
"//the results are stored in an array of size num_work_groups\n"
"kernel void computeLogAvgLum( 	__read_only image2d_t image,\n"
"								__global float* lum,\n"
"								__global float* logAvgLum,\n"
"								__local float* logAvgLum_loc) {\n"
"\n"
"	float lum0;\n"
"	float logAvgLum_acc = 0.f;\n"
"\n"
"	int2 pos;\n"
"	uint4 pixel;\n"
"	for (pos.y = get_global_id(1); pos.y < HEIGHT; pos.y += get_global_size(1)) {\n"
"		for (pos.x = get_global_id(0); pos.x < WIDTH; pos.x += get_global_size(0)) {\n"
"			pixel = read_imageui(image, sampler, pos);\n"
"			// lum0 = pixel.x * 0.2126f + pixel.y * 0.7152f + pixel.z * 0.0722f;\n"
"			lum0 = dot(GLtoCL(pixel.xyz), (float3)(0.2126f, 0.7152f, 0.0722f));\n"
"\n"
"			logAvgLum_acc += log(lum0 + 0.000001f);\n"
"			lum[pos.x + pos.y*WIDTH] = lum0;\n"
"		}\n"
"	}\n"
"\n"
"	pos.x = get_local_id(0);\n"
"	pos.y = get_local_id(1);\n"
"	const int lid = pos.x + pos.y*get_local_size(0);	//local id in one dimension\n"
"	logAvgLum_loc[lid] = logAvgLum_acc;\n"
"\n"
"	// Perform parallel reduction\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"\n"
"	for(int offset = (get_local_size(0)*get_local_size(1))/2; offset > 0; offset = offset/2) {\n"
"		if (lid < offset) {\n"
"			logAvgLum_loc[lid] += logAvgLum_loc[lid + offset];\n"
"		}\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"	}\n"
"\n"
"	const int num_work_groups = get_global_size(0)/get_local_size(0);	//number of workgroups in x dim\n"
"	const int group_id = get_group_id(0) + get_group_id(1)*num_work_groups;\n"
"	if (lid == 0) {\n"
"		logAvgLum[group_id] = logAvgLum_loc[0];\n"
"	}\n"
"}\n"
"\n"
"//combines the results of computeLogAvgLum kernel\n"
"kernel void finalReduc(	__global float* logAvgLum_acc,\n"
"						const unsigned int num_reduc_bins) {\n"
"	if (get_global_id(0)==0) {\n"
"\n"
"		float logAvgLum = 0.f;\n"
"		for (uint i=0; i < num_reduc_bins; i++) {\n"
"			logAvgLum += logAvgLum_acc[i];\n"
"		}\n"
"		logAvgLum_acc[0] = KEY / exp(logAvgLum/(convert_float(WIDTH*HEIGHT)));\n"
"	}\n"
"	else return;\n"
"}\n"
"\n"
"//computes the next level mipmap\n"
"kernel void channel_mipmap(	__global float* mipmap,	//array containing all the mipmap levels\n"
"							const int prev_width,	//width of the previous mipmap\n"
"							const int prev_offset, 	//start point of the previous mipmap \n"
"							const int m_width,		//width of the mipmap being generated\n"
"							const int m_height,		//height of the mipmap being generated\n"
"							const int m_offset) { 	//start point to store the current mipmap\n"
"	int2 pos;\n"
"	for (pos.y = get_global_id(1); pos.y < m_height; pos.y += get_global_size(1)) {\n"
"		for (pos.x = get_global_id(0); pos.x < m_width; pos.x += get_global_size(0)) {\n"
"			int _x = 2*pos.x;\n"
"			int _y = 2*pos.y;\n"
"			mipmap[pos.x + pos.y*m_width + m_offset] = 	(mipmap[_x + _y*prev_width + prev_offset]\n"
"														+ mipmap[_x+1 + _y*prev_width + prev_offset]\n"
"														+ mipmap[_x + (_y+1)*prev_width + prev_offset]\n"
"														+ mipmap[(_x+1) + (_y+1)*prev_width + prev_offset])/4.f;\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"\n"
"//computes the mapping for each pixel as per Reinhard's Local TMO\n"
"kernel void reinhardLocal(	__global float* Ld_array,	//array to hold the mappings for each pixel. output of this kernel\n"
"							__global float* lumMips,	//contains the entire mipmap pyramid for the luminance of the image\n"
"							__global int* m_width,	//width of each of the mipmaps\n"
"							__global int* m_offset,	///set of indices denotaing the start point of each mipmap in lumMips array\n"
"							__global float* logAvgLum_acc) {\n"
"\n"
"	float factor = logAvgLum_acc[0]; // originally (KEY / logAvgLum_acc[0])\n"
"\n"
"#define PHI_IS_EIGHT_POINT_NOUGHT\n"
"#ifndef PHI_IS_EIGHT_POINT_NOUGHT\n"
"	float k[7];\n"
"\t\tconst float scale_sq[7] = \\\n"
"		{ 1.f*1.f, 2.f*2.f, 4.f*4.f, 8.f*8.f, 16.f*16.f, 32.f*32.f, 64.f*64.f };\n"
"	for (int i=0; i<NUM_MIPMAPS-1; i++) {\n"
"		k[i] = pow(2.f, PHI) * KEY / scale_sq[i];\n"
"	}\n"
"#else\n"
"	constant float k[7] = {\n"
"		256.f * KEY / ( 1.f*1.f ),\n"
"		256.f * KEY / ( 2.f*2.f ),\n"
"		256.f * KEY / ( 4.f*4.f ),\n"
"		256.f * KEY / ( 8.f*8.f ),\n"
"		256.f * KEY / (16.f*16.f),\n"
"		256.f * KEY / (32.f*32.f),\n"
"		256.f * KEY / (64.f*64.f)\n"
"	};\n"
"#endif\n"
"\n"
"	int2 pos, centre_pos, surround_pos;\n"
"	for (pos.y = get_global_id(1); pos.y < HEIGHT; pos.y += get_global_size(1)) {\n"
"		for (pos.x = get_global_id(0); pos.x < WIDTH; pos.x += get_global_size(0)) {\n"
"			surround_pos = pos;\n"
"			float local_logAvgLum = 0.f;\n"
"			for (uint i = 0; i < NUM_MIPMAPS-1; i++) {\n"
"				centre_pos = surround_pos;\n"
"				surround_pos = centre_pos/2;\n"
"\n"
"				int2 m_width_01, m_offset_01;\n"
"				m_width_01\t= vload2(0, &m_width[i]);\n"
"				m_offset_01 = vload2(0, &m_offset[i]);\n"
"\n"
"				int2 index_01 = m_offset_01 + (int2)(centre_pos.x, surround_pos.x);\n"
"				index_01 += m_width_01 * (int2)(centre_pos.y, surround_pos.y);\n"
"\n"
"				float2 lumMips_01 = factor;\n"
"				lumMips_01 *= (float2)(lumMips[index_01.s0], lumMips[index_01.s1]);\n"
"\n"
"				float centre_logAvgLum, surround_logAvgLum;\n"
"				centre_logAvgLum\t = lumMips_01.s0;\n"
"				surround_logAvgLum = lumMips_01.s1;\n"
"\n"
"				float cs_diff = fabs(centre_logAvgLum - surround_logAvgLum);\n"
"				if (cs_diff > (k[i] + centre_logAvgLum) * EPSILON) {\n"
"					local_logAvgLum = centre_logAvgLum;\n"
"					break;\n"
"				} else {\n"
"					local_logAvgLum = surround_logAvgLum;\n"
"				}\n"
"			}\n"
"			Ld_array[pos.x + pos.y*WIDTH] = factor / (1.f + local_logAvgLum);\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"//applies the previously computed mappings to image pixels\n"
"kernel void tonemap(__read_only image2d_t input_image,\n"
"					__write_only image2d_t output_image,\n"
"					__global float* Ld_array) {\n"
"	int2 pos;\n"
"	uint4 pixel;\n"
"	float3 rgb, xyz;\n"
"	for (pos.y = get_global_id(1); pos.y < HEIGHT; pos.y += get_global_size(1)) {\n"
"		for (pos.x = get_global_id(0); pos.x < WIDTH; pos.x += get_global_size(0)) {\n"
"			pixel = read_imageui(input_image, sampler, pos);\n"
"\n"
"			rgb = GLtoCL(pixel.xyz);\n"
"			xyz = RGBtoXYZ(rgb);\n"
"\n"
"			float Ld\t= Ld_array[pos.x + pos.y*WIDTH] * xyz.y;\n"
"\n"
"			pixel.xyz = convert_uint3((float3)255.f * \\\n"
"				clamp((pow(rgb.xyz/xyz.y, (float3)SAT)*(float3)Ld), 0.f, 1.f));\n"
"\n"
"			write_imageui(output_image, pos, pixel);\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"\n"
"//convert an RGB pixel to XYZ format:\n"
"//	xyz.x = rgb.x*0.4124f + rgb.y*0.3576f + rgb.z*0.1805f;\n"
"//	xyz.y = rgb.x*0.2126f + rgb.y*0.7152f + rgb.z*0.0722f;\n"
"//	xyz.z = rgb.x*0.0193f + rgb.y*0.1192f + rgb.z*0.9505f;\n"
"float3 RGBtoXYZ(float3 rgb) {\n"
"	float3 xyz;\n"
"	xyz.x = dot(rgb, (float3)(0.4124f, 0.3576f, 0.1805f)); // will be optimised away\n"
"	xyz.y = dot(rgb, (float3)(0.2126f, 0.7152f, 0.0722f));\n"
"	xyz.z = dot(rgb, (float3)(0.0193f, 0.1192f, 0.9505f)); // will be optimised away\n"
"	return xyz;\n"
"}\n"
"\n"
"\n"
"//convert a single OpenGL texture pixel component to an OpenCL texture pixel component\n"
"float GLtoCL1(uint val) {\n"
"	float valf = convert_float(val);\n"
"#if 1 == BUGGY_CL_GL\n"
"	// a workaround for Snapdragon's Android OpenCL implementation\n"
"	if (val >= 14340) return round(0.1245790f*valf - 1658.44f);	//>=128\n"
"	if (val >= 13316) return round(0.0622869f*valf - 765.408f);	//>=64\n"
"	if (val >= 12292) return round(0.0311424f*valf - 350.800f);	//>=32\n"
"	if (val >= 11268) return round(0.0155702f*valf - 159.443f);	//>=16\n"
"	\n"
"	return round(\n"
"		pow(valf, 4.f) * 0.0000000000000125922f -\n"
"		pow(valf, 3.f) * 0.00000000026729f +\n"
"		pow(valf, 2.f) * 0.00000198135f -\n"
"		valf * 0.00496681f -\n"
"		0.0000808829f);\n"
"#else\n"
"	return valf;\n"
"#endif\n"
"}\n"
"\n"
"\n"
"//convert an OpenGL texture pixel to an OpenCL texture pixel\n"
"float3 GLtoCL(uint3 val) {\n"
"	return (float3)(GLtoCL1(val.x), GLtoCL1(val.y), GLtoCL1(val.z));\n"
"}\n"
;
